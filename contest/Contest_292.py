import collections
import heapq
from typing import *
from collections import *
from math import *

from Tree import *

def get_mask(word):
    return sum(1 << (ord(c) - ord("a")) for c in word)


class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.weight = [1 for _ in range(n)]

    def find(self, u):
        if u != self.parent[u]:
            self.parent[u] = self.find(self.parent[u])  # Path compression
        return self.parent[u]

    def union(self, u, v):
        pu, pv = self.find(u), self.find(v)
        if pu != pv:
            if self.weight[pu] < self.weight[pv]:
                self.parent[pu] = pv
                self.weight[pv] = self.weight[pu] + self.weight[pv]
            else:
                self.parent[pv] = pu
                self.weight[pu] = self.weight[pu] + self.weight[pv]

# class Solution:
#     def largestGoodInteger(self, num: str) -> str:
#         ans = ''
#         n = len(num)
#         for i in range(n - 2):
#             if num[i] == num[i + 1] == num[i + 2]:
#                 if not ans:
#                     ans = int(num[i])
#                 else:
#                     ans = max(ans, int(num[i]))
#         if ans == '':
#             return ''
#         else:
#             return str(ans) * 3
#
# s = Solution()
# # num = "6777133339"
# num = "2300019"
# # num = "42352338"
# print(s.largestGoodInteger(num))

# class Solution:
#     def averageOfSubtree(self, root: Optional[TreeNode]) -> int:
#         ans = 0
#
#         def dfs(root):
#             nonlocal ans
#             if not root:
#                 return 0, 0
#
#             lv, ln = dfs(root.left)
#             rv, rn = dfs(root.right)
#
#             v = lv + rv + root.val
#             n = ln + rn + 1
#             if v // n == root.val:
#                 ans += 1
#             return v, n
#
#         dfs(root)
#         return ans


# class Solution:
#     def countTexts(self, A: str) -> int:
#         MOD = 1000000007
#         dp = {}
#         dp[-1] = 1
#         dp[0] = 1
#
#         n = len(A)
#
#         for i in range(1, n):
#             dp[i] = dp[i - 1]
#             if A[i] == A[i - 1]:
#                 dp[i] += dp[i - 2]
#                 if i > 1 and A[i - 1] == A[i - 2]:
#                     dp[i] += dp[i - 3]
#                     if i > 2 and A[i - 2] == A[i - 3] and A[i] in ("7", "9"):
#                         dp[i] += dp[i - 4]
#             dp[i] %= MOD
#
#         # print(dp)
#         return dp[n - 1]
#
#
# s = Solution()
# # pressedKeys = "22233"
# pressedKeys = "222222222222222222222222222222222222"
# pressedKeys = "444479999555588866"  # 3136
# print(s.countTexts(pressedKeys))


class Solution:
    def hasValidPath(self, grid: List[List[str]]) -> bool:
        n = len(grid)
        m = len(grid[0])

        if (n + m) % 2 == 0:
            return False
        total = n + m - 1
        half = total // 2

        ans = False
        mem = set()

        def dfs(cur, x, y):
            nonlocal ans
            if ans:
                return
            if x == n or y == m:
                return
            if (cur, x, y) in mem:
                return
            mem.add((cur, x, y))

            if x == n - 1 and y == m - 1:
                if cur == 1 and grid[x][y] == ')':
                    ans = True
                return

            if grid[x][y] == '(':
                cur += 1
                if cur > half:
                    return
            else:
                if cur <= 0:
                    return
                cur -= 1
            dfs(cur, x + 1, y)
            dfs(cur, x, y + 1)

        dfs(0, 0, 0)
        return ans

s = Solution()
grid = [["(","(","("],[")","(",")"],["(","(",")"],["(","(",")"]]
# grid = [[")",")"],["(","("]]
# grid = [["(","(",")","(",")","(","(",")","(","(",")",")",")",")",")","(",")","(","(",")","(","(",")",")",")",")",")","(","(","(","("],[")","(","(","(",")","(",")","(","(",")",")",")",")","(",")",")","(","(",")",")","(",")","(",")","(","(",")","(",")","(","("],[")",")","(","(",")","(","(",")",")",")",")","(","(",")",")","(",")","(",")",")","(","(","(",")",")",")","(",")",")","(",")"],["(","(",")","(",")","(","(",")","(","(","(",")",")","(",")","(",")",")",")",")",")",")","(","(",")","(",")","(",")","(","("],[")",")","(",")",")","(","(","(",")",")","(",")","(",")",")",")","(","(","(",")",")","(",")","(",")",")","(","(","(","(",")"],[")",")","(","(",")","(",")","(",")","(",")","(",")",")","(",")","(",")",")","(",")","(","(","(",")","(",")",")",")","(","("],[")","(","(","(","(","(","(",")",")","(","(",")","(",")",")","(",")",")",")","(","(","(",")","(","(",")",")","(",")","(",")"],[")",")","(","(","(","(","(","(","(",")",")","(","(","(","(","(","(","(","(","(","(","(","(",")",")","(","(",")",")","(",")"],["(",")",")",")","(","(",")",")",")",")","(",")",")","(",")",")","(","(","(","(","(","(","(",")",")","(","(",")",")","(","("],["(","(",")","(",")",")",")",")","(","(","(",")",")",")","(",")","(","(",")","(","(","(",")","(","(","(","(","(",")",")",")"],["(",")","(","(","(","(",")","(","(",")",")","(","(",")","(","(","(",")","(","(","(",")",")","(",")",")","(",")","(","(",")"],[")",")","(","(","(","(",")","(","(",")",")","(",")",")","(",")","(","(","(","(","(","(","(",")","(","(",")",")","(","(","("],["(",")",")",")","(",")","(","(","(",")",")",")","(",")","(",")",")","(","(","(","(",")","(",")",")",")",")",")",")","(","("],["(","(","(","(","(","(",")",")","(",")","(","(","(",")",")","(",")","(",")","(",")","(","(","(",")",")",")","(",")","(","("],["(",")",")",")",")","(","(",")",")",")",")",")",")","(","(",")","(",")",")","(",")","(",")",")",")","(","(",")","(","(","("],["(",")",")","(","(",")",")","(",")",")","(","(","(",")",")",")",")","(","(","(",")",")","(",")","(","(","(","(",")",")",")"],[")","(","(",")","(","(",")",")",")","(","(","(","(",")","(",")",")",")","(",")","(",")","(","(",")","(","(","(","(","(","("],["(",")","(",")","(","(",")",")",")",")",")","(","(",")",")","(",")","(",")",")",")",")","(","(","(",")","(",")","(",")",")"],["(",")","(",")",")",")","(","(","(",")","(",")","(","(",")",")","(",")","(",")","(",")","(","(","(","(","(",")","(",")","("],[")",")",")",")",")","(",")",")","(","(",")","(",")",")","(",")",")","(","(","(","(",")","(","(","(","(",")",")",")",")","("],[")","(","(","(","(","(",")","(",")",")",")",")","(","(","(",")",")","(",")",")","(","(","(","(","(","(",")",")","(","(","("],["(","(","(",")",")","(",")","(",")",")",")",")","(",")",")",")",")","(",")","(","(","(","(",")","(","(","(","(","(","(",")"]]
print(s.hasValidPath(grid))

































































