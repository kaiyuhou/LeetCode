from typing import *
from Tree import *

class UnionFind:
    def __init__(self):
        self.parent = {}

    def find(self, u):
        if u != self.parent.setdefault(u, u):
            self.parent[u] = self.find(self.parent[u])  # Path compression
        return self.parent[u]

    def union(self, u, v):
        pu, pv = self.find(u), self.find(v)
        if pu != pv:
            self.parent[pu] = pv


# import collections
#
# class Solution:
#     def findEvenNumbers(self, digits: List[int]) -> List[int]:
#         C = collections.Counter(digits)
#         ans = []
#         for i in range(100, 1000, 2):
#             ls = collections.Counter(list(map(int, str(i))))
#             for k, v in ls.items():
#                 if v > C[k]:
#                     break
#             else:
#                 ans.append(i)
#         return ans
#
# s = Solution()

# digits = [2,2,8,8,2]
# print(s.findEvenNumbers(digits))

# class Solution:
#     def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
#         n = 0
#         p = head
#         while p != None:
#             n += 1
#             p = p.next
#
#         if n == 1:
#             return None
#
#         p = head
#         cur = 0
#         mid = n // 2
#
#         while p != None:
#             cur += 1
#             if cur == mid:
#                 p.next = p.next.next
#                 return head
#             p = p.next


# class Solution:
#     def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
#         # (0, 0) find_start, find_end
#         ans = ""
#
#         def dfs(root):
#             nonlocal ans
#             if ans:
#                 return None, None
#
#             rnt = [None, None]
#             if root.val == startValue:
#                 rnt[0] = ""
#             if root.val == destValue:
#                 rnt[1] = ""
#
#
#             if root.left:
#                 s, e = dfs(root.left)
#                 if s != None:
#                     rnt[0] = s + "U"
#
#                 if e != None:
#                     rnt[1] = 'L' + e
#
#             if root.right:
#                 s, e = dfs(root.right)
#                 if s != None:
#                     rnt[0] = s + "U"
#
#                 if e != None:
#                     rnt[1] = 'R' + e
#
#             if rnt[0] is not None and rnt[1] is not None:
#                 ans = rnt[0] + rnt[1]
#
#             if ans:
#                 return None, None
#
#             return rnt[0], rnt[1]
#
#         dfs(root)
#         return ans


from collections import Counter

class Solution:
    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        c = {}
        nxt = {}
        pre = {}
        for a, b in pairs:
            if a not in nxt:
                nxt[a] = []
            nxt[a].append(b)

            if b not in pre:
                pre[b] = []
            pre[b].append(a)

            c[a] = c.get(a, 0) + 1
            c[b] = c.get(b, 0) - 1

        start, end = pairs[0][0], pairs[0][0]
        for k, v in c.items():
            if v == 1:
                start = k
            if v == -1:
                end = k
        #
        # print(len(pairs), c)
        # print(start, end)
        #
        # ks = list(nxt.keys())
        # ks.sort()
        #
        # for k in ks:
        #     print(k, nxt[k])

        av = set()
        for a in pre[end]:
            if a in pre:
                av |= set(pre[a])

        ans = []
        for i in range(len(pairs)):
            if len(nxt[start]) == 0:
                break
            cur = nxt[start].pop()
            # if cur in av:
            #     nxt[start] = [cur] + nxt[start]
            #     cur = nxt[start].pop()
            #
            # if cur in pre[end]:
            #     nxt[start] = [cur] + nxt[start]
            #     cur = nxt[start].pop()

            if cur == end:
                nxt[start] = [end] + nxt[start]
                cur = nxt[start].pop()

            ans.append([start, cur])
            # print(i, ans)
            start = cur

        while len(ans) < len(pairs):
            for i in range(len(ans)):
                if nxt[ans[i][1]]:
                    start = ans[i][1]
                    bstart = start
                    nans = []
                    while len(nxt[start]) > 0:
                        cur = nxt[start].pop()
                        nans.append([start,cur])
                        if cur == bstart:
                            break
                    if nans and nans[-1][1] == bstart:
                        ans = ans[:i + 1] + nans + ans[i + 1:]

        return ans

s = Solution()
pairs = [[5,1],[4,5],[11,9],[9,4]]
pairs = [[1,3],[3,2],[2,1]]
pairs = [[229,699],[489,928],[92,398],[457,398],[798,838],[75,547],[856,141],[838,141],[356,578],[819,537],[229,458],[229,838],[473,175],[545,826],[705,75],[132,262],[92,974],[141,547],[856,92],[229,856],[838,826],[798,15],[892,157],[578,229],[458,905],[141,856],[157,458],[157,489],[92,458],[838,699],[905,458],[547,798],[928,157],[974,15],[545,132],[545,15],[141,132],[458,175],[856,586],[175,705],[547,229],[928,771],[157,671],[175,473],[132,229],[838,671],[458,356],[262,838],[75,262],[92,798],[156,671],[356,124],[547,175],[262,457],[705,545],[671,156],[928,671],[578,892],[483,856],[586,141],[141,838],[974,928],[356,157],[398,586],[15,157],[905,175],[856,157],[157,856],[398,771],[892,586],[974,473],[262,458],[175,141],[458,92],[175,856],[905,974],[928,229],[826,699],[826,483],[826,905],[905,838],[928,356],[974,905],[124,356],[124,537],[771,545],[262,771],[157,928],[229,157],[547,141],[928,75],[262,974],[856,798],[92,132],[15,141],[141,819],[458,15],[141,905],[458,928],[537,586],[92,819],[473,262],[578,473],[141,458],[15,856],[132,798],[537,974],[586,398],[928,141],[141,262],[771,141],[458,974],[157,771],[398,175],[838,974],[826,92],[175,892],[974,157],[838,356],[699,229],[356,489],[15,771],[771,905],[586,92],[771,92],[798,826],[92,537],[699,458],[671,928],[771,928],[398,928],[699,157],[458,157],[537,905],[974,578],[671,92],[671,75],[157,75],[156,838],[473,398],[928,705],[15,458],[705,458],[157,15],[819,124],[157,92],[699,928],[905,699],[798,262],[458,547],[586,856],[974,489],[856,545],[75,974],[75,578],[905,826],[856,705],[489,547]]
pairs = [[17,18],[18,10],[10,18]]
pairs = [[414,87],[602,366],[681,774],[900,274],[406,13],[46,74],[125,213],[812,553],[630,274],[585,569],[87,989],[593,418],[497,10],[932,602],[10,989],[622,277],[16,208],[773,494],[630,523],[698,29],[149,977],[593,87],[616,70],[585,46],[989,13],[846,64],[52,151],[557,911],[319,8],[483,710],[277,880],[377,812],[984,248],[656,319],[824,354],[494,884],[134,337],[712,380],[479,507],[72,900],[396,519],[213,421],[886,222],[519,656],[78,208],[421,4],[987,115],[639,188],[70,335],[444,976],[848,779],[188,127],[10,951],[459,67],[814,52],[557,37],[989,763],[8,140],[661,494],[418,932],[380,687],[640,927],[366,134],[927,444],[127,717],[459,585],[78,8],[975,481],[29,479],[779,125],[507,240],[494,105],[78,377],[115,662],[720,810],[773,593],[607,848],[763,78],[987,87],[274,661],[553,396],[67,103],[377,779],[297,698],[662,672],[64,106],[927,824],[440,311],[74,820],[37,519],[672,376],[454,72],[222,53],[337,78],[294,297],[106,824],[763,987],[354,814],[294,593],[717,175],[53,236],[291,951],[236,622],[880,661],[542,54],[8,773],[87,712],[406,377],[569,616],[54,870],[977,366],[661,421],[396,294],[208,396],[870,16],[779,987],[519,507],[62,630],[4,459],[376,291],[710,477],[911,294],[820,414],[274,46],[13,846],[507,975],[884,959],[976,406],[911,770],[959,585],[208,927],[770,240],[335,62],[523,720],[240,557],[58,497],[151,886],[810,639],[13,630],[105,763],[824,406],[112,542],[248,557],[951,977],[140,773],[87,78],[477,984],[774,112],[103,884],[977,58],[884,10],[311,681],[46,208],[687,607],[208,640],[240,149],[951,454],[421,459],[175,483],[481,440]]
print(s.validArrangement(pairs))



ans = [[156,838],[838,141],[141,856],[856,141],[141,547],[547,229],[229,458],[458,175],[175,473],[473,175],[175,705],[705,75],[75,547],[458,905],[905,458],[229,699],[699,229],[547,798],[798,838],[838,356],[356,157],[157,92],[92,537],[537,905],[905,826],[826,92],[92,819],[819,124],[124,537],[537,974],[974,578],[578,473],[473,398],[398,928],[928,705],[705,458],[458,547],[547,141],[141,262],[262,974],[974,157],[157,15],[15,458],[458,157],[157,75],[75,578],[578,892],[892,586],[586,856],[856,705],[705,545],[545,15],[15,771],[771,928],[928,141],[141,458],[458,974],[974,905],[905,699],[699,928],[928,75],[75,974],[974,473],[473,262],[262,771],[771,92],[92,132],[132,798],[798,262],[262,458],[458,928],[928,356],[356,124],[124,356],[356,578],[578,229],[229,157],[157,771],[771,905],[905,838],[838,974],[974,928],[928,229],[229,856],[856,545],[545,132],[132,229],[229,838],[838,671],[671,156],[156,671],[671,75],[75,262],[262,457],[457,398],[398,175],[175,892],[892,157],[157,928],[928,671],[671,92],[92,798],[798,826],[826,905],[905,974],[974,15],[15,856],[856,798],[798,15],[15,141],[141,905],[905,175],[175,856],[856,157],[157,856],[856,586],[586,92],[92,458],[458,15],[15,157],[157,671],[671,928],[928,771],[771,141],[141,819],[819,537],[537,586],[586,398],[398,771],[771,545],[545,826],[826,483],[483,856],[856,92],[92,974],[974,489],[489,547],[547,175],[175,141],[141,838],[838,699],[699,157],[157,458],[458,92],[92,398],[398,586],[586,141],[141,132],[132,262],[262,838],[838,826],[826,699],[699,458],[458,356],[356,489],[489,928],[928,157],[157,489]]
for i in range(len(ans) - 1):
    if ans[i][1] != ans[i + 1][0]:
        print(i, ans[i][1], ans[i + 1][0])

# Hierholzer's Algorithm:
route = []
st = [S]
while st:
    while g[st[-1]]:
        st.append(g[st[-1]].pop())
    route.append(st.pop())
route.reverse()











































































